## 2121
`cpuid` is a special machine instruction (opcode `0F A2`) implemented for both
Intel and AMD CPUs. It allows software to query detailed information about the
processor: vendor, model, supported instruction sets (SSE, AVX, VMX/VT-x),
cache layout, topology, performance capabilities, etc.

Although `cpuid` provides a large amount of structured information, the
instruction itself takes no explicit operands - that is, you do *not* write:

```asm
cpuid 1
cpuid eax
cpuid %edx
```

Instead, `cpuid` is a standalone instruction, similar to `nop`, `ret`, ...

However, the CPU interprets register contents as parameters. In other words,
`cpuid` takes parameters, but implicitly, through the values already loaded
into registers. Specifically:
- **EAX**. selects the *primary information category*, which Intel calls a
  **CPUID leaf**
- **ECX** optionally selects a *sub-category* (a **sub-leaf**)

### leaves 
`cpuid` may have many primary information categories (called leaves):

| leaf | meaning                                   |
| ---- | ----------------------------------------- |
| 0    | max leaf and vendor                       |
| 1    | basic features (VMX/VT-x, SSE, AVX, etc.) |
| 2    | TLB/cache descriptors                     |
| 4    | deterministic cache parameters            |
| 7    | extended feature flags                    |
| 0xA  | performance monitoring                    |
| 0xB  | topology (threads per core)               |
| …    | varies by CPU                             |

The [wiki](https://en.wikipedia.org/wiki/CPUID#Calling_CPUID) suggests that
`cpuid` should first be called with `EAX = 0`, because leaf 0 returns basic
information about which CPUID leaves exist. The instruction will write to
`EAX` the highest supported CPUID leaf, and to `EBX`, `ECX`, and `EDX` the CPU
vendor string (e.g. “GenuineIntel”, “AuthenticAMD”, ...).

## 2225
When executing [cpuid.c](../code/ft-c-cpuid/cpuid.c) (in an Alpine VM), I get
the following output:

```bash
localhost:~/src$ ./a.out
max_leaves: 32
cpuid: 1
```

Fascinating... there are 32 (or 0x20) leaves. Alternatively, Linux already
exposes most `cpuid` information in `/proc` and `/sys`; notably,
`/proc/cpuinfo` is the main CPUID-derived file and it may be viewed by:

```bash
cat /proc/cpuinfo
```

There is also a dedicated `cpuid` package though I don't know too much about 
it.

## 2258
Nevermind, I ended up checking out the `cpuid` package in my Alpine VM and
got the following output:

```
localhost:~/cpuid$ cpuid
CPU 0:
Maximum basic CPUID leaf: 0x00000020

CPU vendor string: 'GenuineIntel'

Signature:  0x000906a3
  Family:   0x06 (6)
  Model:    0x9a (154)
  Stepping: 0x03 (3)

Local APIC: 0
Maximum number of APIC IDs per package: 0
CLFLUSH size: 64
Brand ID: 0

Base features, edx:
  x87 FPU on chip
  virtual-8086 mode enhancement
  debugging extensions
  page size extensions
  time stamp counter
  RDMSR and WRMSR support
  physical address extensions
  machine check exception
  CMPXCHG8B instruction
  APIC on chip
  SYSENTER and SYSEXIT instructions
  memory type range registers
  PTE global bit
  machine check architecture
  conditional move instruction
  page attribute table
  36-bit page size extension
  CLFLUSH instruction
  MMX instruction set
  FXSAVE/FXRSTOR instructions
  SSE instructions
  SSE2 instructions
  self snoop
Base features, ecx:
  SSE3 instructions
  PCLMULQDQ instruction
  virtual machine extensions
  SSSE3 instructions
  fused multiply-add AVX instructions
  CMPXCHG16B instruction
  process-context identifiers
  SSE4.1 instructions
  SSE4.2 instructions
  x2APIC
  MOVBE instruction
  POPCNT instruction
  TSC deadline
  AES instructions
  XSAVE/XRSTOR instructions
  OS-enabled XSAVE/XRSTOR
  AVX instructions
  16-bit FP conversion instructions
  RDRAND instruction
  RAZ (hypervisor)

Cache descriptors:
  [NOTICE] For cache data, see Deterministic Cache Parameters leaf instead

Processor serial number: disabled (or not supported)

Deterministic Cache Parameters:
   32KB L1 data cache
        8-way set associative
        64 byte line size
        Self-initializing
        Does not invalidate lower level caches
        Shared by max 1 threads

   32KB L1 code cache
        8-way set associative
        64 byte line size
        Self-initializing
        Does not invalidate lower level caches
        Shared by max 1 threads

    4MB L2 unified cache
        16-way set associative
        64 byte line size
        Self-initializing
        Does not invalidate lower level caches
        Shared by max 1 threads

   16MB L3 unified cache
        16-way set associative
        64 byte line size
        Self-initializing
        Inclusive of lower cache levels
        Complex indexing
        Shared by max 1 threads

Intel Thermal and Power Management Features:
  Always running APIC timer (ARAT)

Structured extended feature flags (ecx=0), ebx:
  FSGSBASE instructions
  IA32_TSC_ADJUST MSR supported
  Bit Manipulation Instructions (BMI1)
  Advanced Vector Extensions 2.0 (AVX2)
  x87 FPU data pointer updated only on x87 exceptions
  Supervisor Mode Execution Protection (SMEP)
  Bit Manipulation Instructions 2 (BMI2)
  Enhanced REP MOVSB/STOSB
  INVPCID instruction
  x87 FPU CS and DS deprecated
  RDSEED instruction
  Multi-Precision Add-Carry Instruction Extensions (ADX)
  Supervisor Mode Access Prevention (SMAP)
  CLFLUSHOPT instruction
  cache line write-back instruction (CLWB)
  SHA-1/SHA-256 instructions
Structured extended feature flags (ecx=0), ecx:
  User Mode Instruction Prevention (UMIP)
  Protection Keys for User-mode pages (PKU)
  Wait and Pause Enhancements (WAITPKG)
  Galois Field NI / Galois Field Affine Transformation (GFNI)
  VEX-encoded AES-NI (VAES)
  VEX-encoded PCLMUL (VPCL)
  Read Processor ID (RDPID)
  32-bit Direct Stores (MOVDIRI)
  64-bit Direct Stores (MOVDIRI64B)
Structured extended feature flags (ecx=0), edx:
  Fast Short REP MOV
  MD_CLEAR
  SERIALIZE
  Speculation Control (IBRS and IBPB)
  Single Thread Indirect Branch Predictors (STIBP)
  L1 Data Cache (L1D) Flush
  IA32_ARCH_CAPABILITIES MSR
  Speculative Store Bypass Disable (SSBD)

Structured extended feature flags (ecx=1), eax:
  AVX Vector Neural Network Instructions (AVX-VNNI)
  Fast short STOSB

Structured extended feature flags (ecx=2), edx:
  Fast store forwarding disable without spec store bypass (PSFD)
  IPRED control
  RRSBA control
  BHI control

x2APIC Processor Topology:
  Inferred information:
    Logical total:       1
    Logical per socket:  1
    Cores per socket:    1
    Threads per core:    1

  x2APIC ID 0 (socket 0, core 0, thread 0)

Extended State Enumeration
  Valid bit fields for lower 32 bits of XCR0:
    0 - Legacy x87
    1 - 128-bit SSE
    2 - 256-bit AVX YMM_Hi128
    9 - Protected keys

  Valid bit fields for upper 32-bits of XCR0:
    0x00000000

  Maximum size required for all enabled features:   832 bytes

  Maximum size required for all supported features: 2696 bytes

  Size of XSAVE area containing all enabled states: 832
  Features available:
    0 - XSAVEOPT
    1 - XSAVEC and compacted XRSTOR
    2 - XGETBV with ECX=1
    3 - XSAVES/XRSTORS and IA32_XSS

  Extended state for 256-bit AVX YMM_Hi128 requires 256 bytes, offset 576

Maximum hypervisor CPUID leaf: 0x40000001

Hypervisor vendor string: 'KVMKVMKVM'

KVM hypervisor detected

KVM features, eax:
  Clocksource
  NOP IO Delay
  Clocksource 2
  Async PF
  Steal Time
  PV EOI
  PV UNHALT
  PV TLB flush
  PV async PF VMEXIT
  PV send IPI
  PV poll control
  PV sched yield
  Async PF INT
  Clocksource Stable

Maximum extended CPUID leaf: 0x80000008

Extended features, edx:
  SYSENTER and SYSEXIT instructions
  XD bit
  1GB page support
  RDTSCP instruction
  long mode (EM64T)
Extended features, ecx:
  LAHF/SAHF supported in 64-bit mode
  LZCNT instruction
  3DNow! prefetch instructions

Processor Name: 12th Gen Intel(R) Core(TM) i5-1240P

Guest physical address size: 39 bits
Physical address size: 39 bits
Linear address size: 48 bits
```
